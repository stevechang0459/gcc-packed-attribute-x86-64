<!DOCTYPE html>
<html lang="zh-Hant" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GCC `packed` 屬性互動式解析</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            background-color: #f8fafc;
        }
        .tab-btn {
            @apply px-4 py-2 font-medium text-sm rounded-md transition-colors duration-200;
        }
        .tab-btn.active {
            @apply bg-blue-600 text-white shadow-sm;
        }
        .tab-btn:not(.active) {
            @apply text-gray-600 hover:bg-gray-200;
        }
        .tab-content {
            @apply hidden;
        }
        .tab-content.active {
            @apply block;
        }
        nav a {
            @apply px-3 py-2 rounded-md text-sm font-medium transition-colors duration-200;
        }
        nav a.active {
            @apply bg-blue-100 text-blue-700;
        }
        nav a:not(.active) {
            @apply text-gray-700 hover:bg-gray-100;
        }
        .highlight-pulse {
            animation: pulse-bg 1.5s ease-out;
        }
        @keyframes pulse-bg {
            0% { background-color: transparent; }
            30% { background-color: #fef9c3; }
            100% { background-color: transparent; }
        }
        pre {
            @apply bg-gray-900 text-white p-4 rounded-lg overflow-x-auto text-sm;
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
            height: 120px;
            max-height: 120px;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 150px;
                max-height: 150px;
            }
        }
    </style>
    <!-- Chosen Palette: Technical Calm (Blue, Gray, Yellow highlight) -->
    <!-- Application Structure Plan:
        設計了一個多區塊的 SPA，透過頂部固定導覽列 (sticky nav) 進行導覽。
        結構: Intro -> Experiment (C Code / Output Tabs) -> Layout (Interactive Chart.js Viz) -> Assembly (Tabs for pxx/sxx) -> Takeaways (Tabs for Perf/Use Cases) -> Appendix.
        核心互動: 點擊 "Layout" 區塊中的 Chart.js 圖表片段 (代表一個 struct 成員) 會觸發 JavaScript，自動捲動到 "Assembly" 區塊，並高亮顯示對應的組合語言指令。
        為何選擇此結構: 這種結構將原始的線性文章轉化為一個以探索為導向的學習工具。它將 C 程式碼、視覺化的記憶體佈局和底層組合語言明確地連結起來，讓使用者能主動探索 "因" (C 程式碼) 和 "果" (記憶體、組合語言)，而不是被動閱讀。分頁 (Tabs) 用於管理資訊密度，防止使用者被過多文字淹沒。
    -->
    <!-- Visualization & Content Choices:
        - Report Info: C 程式碼 (pxx, sxx, main)。Goal: 比較/告知。Viz: 兩個 `<pre>` 區塊並排於 "Experiment" 標籤中。Interaction: 閱讀。Justification: 易於比較程式碼差異。
        - Report Info: 執行結果。Goal: 告知。Viz: `<pre>` 區塊於 "Experiment" 標籤中。Interaction: 閱讀。Justification: 顯示程式的原始輸出。
        - Report Info: 記憶體佈局比較表。Goal: 比較/分析/互動。Viz: 兩個 Chart.js 水平堆疊長條圖 (Canvas)。一個用於 `pxx`，一個用於 `sxx`。圖表顯示成員和 padding。Library: Chart.js。
          Interaction: `onClick` 事件處理器。點擊圖表的一個區段 (如 'p.b') 會觸發 JS 函數，該函數會：1. 啟動 "Assembly" 區塊的 "pxx" 標籤。 2. 捲動到 ID 為 'asm-p-b' 的指令行。 3. 觸發 'highlight-pulse' CSS 動畫。
          Justification: 這是最關鍵的互動元素。它將抽象的記憶體佈局視覺化，並將其直接與組合語言的證據連結起來，極大地增強了學習體驗。
        - Report Info: 組合語言分析 (pxx vs sxx)。Goal: 比較/分析。Viz: `<pre>` 區塊於 "Assembly" 的標籤中。關鍵指令 (如 `movl ... -13(%rbp)`) 用 `<span>` 包裹並給予 ID (如 `id="asm-p-b"`)。Interaction: 接收來自圖表點擊的捲動和高亮事件。Justification: 提供了 unaligned vs aligned 存取的直接證據。
        - Report Info: 效能/使用時機/架構差異。Goal: 告知/總結。Viz: HTML 文字內容 (`<p>`, `<ul>`) 於 "Takeaways" 標籤中。Interaction: 標籤切換。Justification: 在使用者理解 "如何" 之後，提供 "為何" 的上下文。
        - CONFIRMATION: NO SVG graphics used. NO Mermaid JS used.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
</head>
<body class="text-gray-800">

    <nav class="sticky top-0 z-50 bg-white shadow-md">
        <div class="container mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between h-16">
                <div class="flex-shrink-0 flex items-center">
                    <h1 class="text-xl font-bold text-blue-600">GCC `packed` 屬性解析</h1>
                </div>
                <div class="hidden sm:ml-6 sm:flex sm:space-x-8" id="nav-links">
                    <a href="#intro" class="inline-flex items-center">簡介</a>
                    <a href="#experiment" class="inline-flex items-center">C 語言實驗</a>
                    <a href="#layout" class="inline-flex items-center">記憶體佈局</a>
                    <a href="#assembly" class="inline-flex items-center">組合語言分析</a>
                    <a href="#takeaways" class="inline-flex items-center">關鍵總結</a>
                    <a href="#appendix" class="inline-flex items-center">附錄</a>
                </div>
            </div>
        </div>
    </nav>

    <main class="container mx-auto p-4 sm:p-6 lg:p-8">

        <section id="intro" class="scroll-mt-16 mb-12">
            <div class="bg-white p-6 rounded-lg shadow-sm">
                <h2 class="text-2xl font-bold text-gray-900 mb-4">歡迎來到 `packed` 屬性互動解析</h2>
                <p class="text-gray-700 leading-relaxed">
                    在 C 語言的系統程式設計中，特別是在處理硬體、封包或二進位檔案格式的時候，精確控制 `struct` 的記憶體佈局 (layout) 至關重要。GCC 編譯器提供的 `__attribute__((packed))` 屬性便是一個強力工具，它能協助開發者移除編譯器為了對齊 (alignment) 自動添加的填充位元組 (padding)，以建立最緊湊的資料結構。本應用將帶您深入探討 `packed` 屬性的作用、對記憶體和組合語言的影響，以及其潛在的效能取捨。
                </p>
            </div>
        </section>

        <section id="experiment" class="scroll-mt-16 mb-12">
            <div class="bg-white p-6 rounded-lg shadow-sm">
                <h2 class="text-2xl font-bold text-gray-900 mb-4">C 語言實驗</h2>
                <p class="text-gray-700 leading-relaxed mb-6">
                    我們將比較兩個 C 語言結構：`struct pxx` 使用了 `__attribute__((packed))` 屬性，而 `struct sxx` 則使用編譯器預設的對齊規則。下方的標籤頁顯示了我們用來比較的 C 程式碼，以及編譯執行後的實際輸出。
                </p>

                <div class="mb-4 border-b border-gray-200">
                    <nav class="flex space-x-2" data-tab-group="exp">
                        <button class="tab-btn active" data-tab="exp-code">C 程式碼</button>
                        <button class="tab-btn" data-tab="exp-output">執行結果</button>
                    </nav>
                </div>

                <div id="exp-code" class="tab-content active" data-tab-group="exp">
                    <div class="grid md:grid-cols-2 gap-4">
                        <div>
                            <h3 class="font-semibold text-lg mb-2">Packed 結構 (`struct pxx`)</h3>
<pre>
struct pxx {
    uint8_t a;
    uint32_t b;
    uint8_t c;
    uint8_t d;
    uint8_t e;
    uint16_t f;
} __attribute__((packed));
</pre>
                        </div>
                        <div>
                            <h3 class="font-semibold text-lg mb-2">Standard 結構 (`struct sxx`)</h3>
<pre>
struct sxx {
    uint8_t a;
    uint32_t b;
    uint8_t c;
    uint8_t d;
    uint8_t e;
    uint16_t f;
};
</pre>
                        </div>
                    </div>
                    <h3 class="font-semibold text-lg mt-6 mb-2">Main 函數</h3>
<pre>
int main(int argc, char *argv[])
{
    struct pxx p;
    memset(&p, 0, sizeof(p));
    p.a = 0x11;
    p.b = 0x22334455;
    p.c = 0x66;
    p.d = 0x77;
    p.e = 0x88;
    p.f = 0x99AA;

    printf("sizeof(p):%lld\n", sizeof(p));
    // ... (printf for p members) ...

    struct sxx s;
    memset(&s, 0, sizeof(s));
    s.a = 0x11;
    s.b = 0x22334455;
    s.c = 0x66;
    s.d = 0x77;
    s.e = 0x88;
    s.f = 0x99AA;

    printf("sizeof(s):%lld\n", sizeof(s));
    // ... (printf for s members) ...

    return 0;
}
</pre>
                </div>

                <div id="exp-output" class="tab-content" data-tab-group="exp">
                    <h3 class="font-semibold text-lg mb-2">Console 輸出</h3>
<pre>
# ./bin/c-test.exe
sizeof(p):10
&p:000000E5D19FF962
p.a: 000000E5D19FF962,       11, 1
p.b: 000000E5D19FF963, 22334455, 4
p.c: 000000E5D19FF967,       66, 1
p.d: 000000E5D19FF968,       77, 1
p.e: 000000E5D19FF969,       88, 1
p.f: 000000E5D19FF96A,     99aa, 2

sizeof(s):16
&s:000000E5D19FF950
s.a: 000000E5D19FF950,       11, 1
s.b: 000000E5D19FF954, 22334455, 4
s.c: 000000E5D19FF958,       66, 1
s.d: 000000E5D19FF959,       77, 1
s.e: 000000E5D19FF95A,       88, 1
s.f: 000000E5D19FF95C,     99aa, 2
</pre>
                </div>
            </div>
        </section>

        <section id="layout" class="scroll-mt-16 mb-12">
            <div class="bg-white p-6 rounded-lg shadow-sm">
                <h2 class="text-2xl font-bold text-gray-900 mb-4">互動式記憶體佈局</h2>
                <p class="text-gray-700 leading-relaxed mb-6">
                    這是本分析的核心。下方的圖表使用 Chart.js 將兩個結構體的記憶體佈局視覺化。`struct pxx` (packed) 顯示了成員如何緊密排列，總大小為 10 bytes。`struct sxx` (standard) 則顯示了編譯器為了對齊而自動插入的 `padding` (灰色區塊)，總大小為 16 bytes。<br>
                    <strong class="text-blue-600">
                        試著點擊任一成員 (例如 `p.b` 或 `s.b`)，看看它在組合語言中的對應操作！
                    </strong>
                </p>

                <h3 class="font-semibold text-lg mb-3 text-center">`struct pxx` (Packed) - 總大小: 10 Bytes</h3>
                <div class="chart-container">
                    <canvas id="packedChart"></canvas>
                </div>

                <h3 class="font-semibold text-lg mt-8 mb-3 text-center">`struct sxx` (Standard) - 總大小: 16 Bytes</h3>
                <div class="chart-container">
                    <canvas id="standardChart"></canvas>
                </div>
            </div>
        </section>

        <section id="assembly" class="scroll-mt-16 mb-12">
            <div class="bg-white p-6 rounded-lg shadow-sm">
                <h2 class="text-2xl font-bold text-gray-900 mb-4">組合語言分析</h2>
                <p class="text-gray-700 leading-relaxed mb-6">
                    `packed` 屬性最顯著的影響體現在產生的組合語言上。編譯器必須產生不同的指令來存取「未對齊」和「已對齊」的記憶體。請注意 `movl` (4-byte move) 指令存取的堆疊位址：
                </p>

                <div class="mb-4 border-b border-gray-200">
                    <nav class="flex space-x-2" data-tab-group="asm">
                        <button class="tab-btn active" data-tab="asm-p">`packed` (`struct pxx`) 組合語言</button>
                        <button class="tab-btn" data-tab="asm-s">Standard (`struct sxx`) 組合語言</button>
                    </nav>
                </div>

                <div id="asm-p" class="tab-content active" data-tab-group="asm">
                    <h3 class="font-semibold text-lg mb-2">`packed` (`struct pxx`) 操作</h3>
                    <p class="mb-4">
                        結構 `p` 從 `-14(%rbp)` 開始。注意 `p.b` (一個 4-byte `uint32_t`) 被寫入到 `-13(%rbp)`，這是一個**未對齊** (unaligned) 的奇數位址，可能導致效能下降。
                    </p>
<pre>
# main.c:27:     memset(&p, 0, sizeof(p));
	leaq	-14(%rbp), %rax	         # p 的基底
	movl	$10, %r8d	         # sizeof(p) = 10
	...
	call	memset
# main.c:29:     p.a = 0x11;
<span id="asm-p-a">	movb	$17, -14(%rbp)	         # p.a (Offset +0)</span>
# main.c:30:     p.b = 0x22334455;
<span id="asm-p-b">	movl	$573785173, -13(%rbp)	 # p.b (Offset +1) - UNALIGNED!</span>
# main.c:31:     p.c = 0x66;
<span id="asm-p-c">	movb	$102, -9(%rbp)	         # p.c (Offset +5)</span>
# main.c:32:     p.d = 0x77;
<span id="asm-p-d">	movb	$119, -8(%rbp)	         # p.d (Offset +6)</span>
# main.c:33:     p.e = 0x88;
<span id="asm-p-e">	movb	$-120, -7(%rbp)	         # p.e (Offset +7)</span>
# main.c:34:     p.f = 0x99AA;
<span id="asm-p-f">	movw	$-26198, -6(%rbp)	 # p.f (Offset +8)</span>
</pre>
                </div>

                <div id="asm-s" class="tab-content" data-tab-group="asm">
                    <h3 class="font-semibold text-lg mb-2">Standard (`struct sxx`) 操作</h3>
                    <p class="mb-4">
                        結構 `s` 從 `-32(%rbp)` 開始 (一個 16-byte 對齊的位址)。編譯器加入了 3 bytes 的 padding，使得 `s.b` 被寫入到 `-28(%rbp)`，這是一個**已對齊** (aligned) 的 4-byte 邊界，CPU 存取效能最高。
                    </p>
<pre>
# main.c:52:     memset(&s, 0, sizeof(s));
	leaq	-32(%rbp), %rax	         # s 的基底
	movl	$16, %r8d	         # sizeof(s) = 16
	...
	call	memset
# main.c:54:     s.a = 0x11;
<span id="asm-s-a">	movb	$17, -32(%rbp)	         # s.a (Offset +0)</span>
# main.c:55:     s.b = 0x22334455;
<span id="asm-s-b">	movl	$573785173, -28(%rbp)	 # s.b (Offset +4) - ALIGNED!</span>
# main.c:56:     s.c = 0x66;
<span id="asm-s-c">	movb	$102, -24(%rbp)	         # s.c (Offset +8)</span>
# main.c:57:     s.d = 0x77;
<span id="asm-s-d">	movb	$119, -23(%rbp)	         # s.d (Offset +9)</span>
# main.c:58:     s.e = 0x88;
<span id="asm-s-e">	movb	$-120, -22(%rbp)	 # s.e (Offset +10)</span>
# main.c:59:     s.f = 0x99AA;
<span id="asm-s-f">	movw	$-26198, -20(%rbp)	 # s.f (Offset +12)</span>
</pre>
                </div>
            </div>
        </section>

        <section id="takeaways" class="scroll-mt-16 mb-12">
            <div class="bg-white p-6 rounded-lg shadow-sm">
                <h2 class="text-2xl font-bold text-gray-900 mb-4">關鍵總結</h2>
                <p class="text-gray-700 leading-relaxed mb-6">
                    `packed` 屬性是一個強大的工具，但它犧牲了效能來換取空間。了解何時使用它至關重要。
                </p>

                <div class="mb-4 border-b border-gray-200">
                    <nav class="flex space-x-2" data-tab-group="take">
                        <button class="tab-btn active" data-tab="take-perf">效能取捨</button>
                        <button class="tab-btn" data-tab="take-use">合理的使用時機</button>
                        <button class="tab-btn" data-tab="take-arch">架構差異</button>
                    </nav>
                </div>

                <div id="take-perf" class="tab-content active" data-tab-group="take">
                    <h3 class="font-semibold text-lg mb-2">效能取捨 (Performance Trade-off)</h3>
                    <ul class="list-disc list-inside space-y-2 text-gray-700">
                        <li><strong>CPU 存取速度：</strong> 現代 CPU (如 x86-64) 被設計為在「對齊」的記憶體位址上讀取資料效率最高。例如，讀取一個 4-byte `uint32_t` 時，如果其位址是 4 的倍數 (如 `0x...A94`)，CPU 通常可以在一個時脈週期內完成。</li>
                        <li><strong>Unaligned 存取懲罰：</strong> 當 CPU 被要求從一個「未對齊」的位址 (如 `0x...A93`) 讀取 4 bytes 資料時，它無法一次完成。CPU 必須執行額外的工作 (例如讀取兩次記憶體，再進行位移和遮罩)，這個過程會比對齊存取慢上許多。</li>
                        <li><strong>結論：</strong> 在我們的範例中，`movl ... -13(%rbp)` (packed) 的效能會低於 `movl ... -28(%rbp)` (standard)。</li>
                    </ul>
                </div>

                <div id="take-use" class="tab-content" data-tab-group="take">
                    <h3 class="font-semibold text-lg mb-2">合理的使用時機</h3>
                    <p class="text-gray-700 mb-4">不應該為了節省一點點記憶體空間而濫用 `packed` 屬性，它僅須在適當的時機被拿來使用：</p>
                    <ul class="list-disc list-inside space-y-2 text-gray-700">
                        <li><strong>硬體暫存器映射：</strong> 當 C 結構需要直接映射到一個硬體的暫存器佈局時。</li>
                        <li><strong>封包定義：</strong> 定義通訊協定的封包結構，需要確保沒有任何 padding 以符合協定規範。</li>
                        <li><strong>檔案格式：</strong> 讀取或寫入特定且緊湊的二進位檔案格式 (例如圖片或音訊檔頭)。</li>
                        <li><strong>系統互通性：</strong> 當需要與使用不同編譯器或不同 pack 規則的程式交換資料時。</li>
                    </ul>
                    <p class="text-gray-700 mt-4">除非正在處理上述情況，否則應該優先使用 C 語言的預設對齊規則，因為這是編譯器為平台所做的最佳效能優化。</p>
                </div>

                <div id="take-arch" class="tab-content" data-tab-group="take">
                    <h3 class="font-semibold text-lg mb-2">架構差異</h3>
                    <p class="text-gray-700 leading-relaxed">
                        雖然 x86-64 (CISC) 允許 unaligned 存取 (但有效能懲罰)，但許多 <strong>RISC</strong> 架構 (如 ARM) 預設情況下 **不允許** unaligned 存取。在這些平台上，嘗試讀取 unaligned 位址可能會觸發硬體異常 (Exception) 並使程式崩潰。因此，在使用 `packed` 屬性時，跨平台的可移植性是一個重要考量。
                    </p>
                </div>
            </div>
        </section>

        <section id="appendix" class="scroll-mt-16 mb-12">
            <div class="bg-white p-6 rounded-lg shadow-sm">
                <h2 class="text-2xl font-bold text-gray-900 mb-4">附錄</h2>
                <p class="text-gray-700 leading-relaxed mb-6">
                    此處包含用於產生分析的 GCC 編譯器選項和完整的 `main.s` 組合語言檔案。
                </p>

                <div class="mb-4 border-b border-gray-200">
                    <nav class="flex space-x-2" data-tab-group="app">
                        <button class="tab-btn active" data-tab="app-opts">GCC Options</button>
                        <button class="tab-btn" data-tab="app-asm">Full `main.s`</button>
                    </nav>
                </div>

                <div id="app-opts" class="tab-content active" data-tab-group="app">
                    <h3 class="font-semibold text-lg mb-2">GCC Options</h3>
                    <p class="mb-4">若想要閱讀帶有 C 註解的組合語言，但又不想產生額外除錯資訊的需求，編譯時我們可以使用下列 GCC 選項：</p>
<pre>
-g0 -O0 -fverbose-asm
</pre>
                    <ul class="list-disc list-inside space-y-2 text-gray-700 mt-4">
                        <li><code>-g0</code>: 產生最少 (沒有) 除錯資訊。</li>
                        <li><code>-O0</code>: 不進行任何優化。這對分析很重要，因為優化會大幅改變組合語言，使其難以對應回原始 C 程式碼。</li>
                        <li><code>-fverbose-asm</code>: 在組合語言中加入額外的註解，例如 C 原始碼行和變數名稱。</li>
                    </ul>
                </div>

                <div id="app-asm" class="tab-content" data-tab-group="app">
                    <h3 class="font-semibold text-lg mb-2">Full `main.s`</h3>
<pre>
	.file	"main.c"
 # GNU C23 (Rev5, Built by MSYS2 project) version 15.1.0 (x86_64-w64-mingw32)
 #	compiled by GNU C version 15.1.0, GMP version 6.3.0, MPFR version 4.2.2, MPC version 1.3.1, isl version isl-0.27-GMP

 # GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
 # options passed: -mtune=generic -march=nocona -g0 -O0
	.text
	.section .rdata,"dr"
.LC0:
	.ascii "sizeof(p):%zu\12\0"
.LC1:
	.ascii "&p:%p\12\0"
.LC2:
	.ascii "p.a: %p, %8x, %zu\12\0"
.LC3:
	.ascii "p.b: %p, %8x, %zu\12\0"
.LC4:
	.ascii "p.c: %p, %8x, %zu\12\0"
.LC5:
	.ascii "p.d: %p, %8x, %zu\12\0"
.LC6:
	.ascii "p.e: %p, %8x, %zu\12\0"
.LC7:
	.ascii "p.f: %p, %8x, %zu\12\0"
.LC8:
	.ascii "x  : %x\12\0"
.LC9:
	.ascii "p.b: %x\12\0"
.LC10:
	.ascii "sizeof(s):%zu\12\0"
.LC11:
	.ascii "&s:%p\12\0"
.LC12:
	.ascii "s.a: %p, %8x, %zu\12\0"
.LC13:
	.ascii "s.b: %p, %8x, %zu\12\0"
.LC14:
	.ascii "s.c: %p, %8x, %zu\12\0"
.LC15:
	.ascii "s.d: %p, %8x, %zu\12\0"
.LC16:
	.ascii "s.e: %p, %8x, %zu\12\0"
.LC17:
	.ascii "s.f: %p, %8x, %zu\12\0"
	.text
	.globl	main
	.def	main;	.scl	2;	.type	32;	.endef
	.seh_proc	main
main:
	pushq	%rbp	                 # 備份 caller 的 frame pointer (%rbp)
	.seh_pushreg	%rbp
	movq	%rsp, %rbp	         # 將目前的 stack pointer (%rsp) 備份到 frame pointer (%rbp) 中
	.seh_setframe	%rbp, 0
	subq	$64, %rsp	         # 將 stack pointer 減去 64 bytes，為所有的區域變數預留空間。
	.seh_stackalloc	64
	.seh_endprologue
	movl	%ecx, 16(%rbp)	         # 儲存傳入的第1個參數 `argc`
	movq	%rdx, 24(%rbp)	         # 儲存傳入的第2個參數 `argv`
 # main.c:25: {
	call	__main	                 # 呼叫 C 語言執行環境(runtime)的初始化
 # main.c:27:     memset(&p, 0, sizeof(p));
	leaq	-14(%rbp), %rax	         # 將 `p` 的位址 (%rbp - 14) 載入到 %rax 中
	movl	$10, %r8d	         # 設定第 3 個參數，size = 10，到 %r8d
	movl	$0, %edx	         # 設定第 2 個參數，value = 0，到 %edx
	movq	%rax, %rcx	         # 設定第 1 個參數，dest = p 的位址，到 %rcx
	call	memset	                 # 呼叫 memset(%rcx, %edx, %r8d)
 # main.c:29:     p.a = 0x11;
	movb	$17, -14(%rbp)	         # p.a，寫入 1 byte (17 = 0x11) 到 (%rbp - 14)
 # main.c:30:     p.b = 0x22334455;
	movl	$573785173, -13(%rbp)	 # p.b，寫入 4 bytes (long) 到 (%rbp - 13)，沒有 padding
 # main.c:31:     p.c = 0x66;
	movb	$102, -9(%rbp)	         # p.c，寫入 1 byte 到 (%rbp - 9)
 # main.c:32:     p.d = 0x77;
	movb	$119, -8(%rbp)	         # p.d，寫入 1 byte 到 (%rbp - 8)
 # main.c:33:     p.e = 0x88;
	movb	$-120, -7(%rbp)	         # p.e，寫入 1 byte 到 (%rbp - 7)
 # main.c:34:     p.f = 0x99AA;
	movw	$-26198, -6(%rbp)	 # p.f，寫入 2 bytes (word) 到 (%rbp - 6)
 # main.c:36:     printf("sizeof(p):%zu\n", sizeof(p));
	leaq	.LC0(%rip), %rax	 #, tmp124
	movl	$10, %edx	 #,
	movq	%rax, %rcx	 # tmp124,
	call	printf	 #
 # main.c:37:     printf("&p:%p\n", &p);
	leaq	-14(%rbp), %rax	 #, tmp125
	leaq	.LC1(%rip), %rcx	 #, tmp126
	movq	%rax, %rdx	 # tmp125,
	call	printf	 #
 # main.c:38:     printf("p.a: %p, %8x, %zu\n", &p.a, p.a, sizeof(p.a));
	movzbl	-14(%rbp), %eax	 # p.a, _1
 # main.c:38:     printf("p.a: %p, %8x, %zu\n", &p.a, p.a, sizeof(p.a));
	movzbl	%al, %edx	 # _1, _2
	leaq	-14(%rbp), %rax	 #, tmp127
	leaq	.LC2(%rip), %rcx	 #, tmp128
	movl	$1, %r9d	 #,
	movl	%edx, %r8d	 # _2,
	movq	%rax, %rdx	 # tmp127,
	call	printf	 #
 # main.c:39:     printf("p.b: %p, %8x, %zu\n", &p.b, p.b, sizeof(p.b));
	movl	-13(%rbp), %ecx	 # p.b, _3
	leaq	-14(%rbp), %rax	 #, tmp129
	leaq	1(%rax), %rdx	 #, tmp130
	leaq	.LC3(%rip), %rax	 #, tmp131
	movl	$4, %r9d	 #,
	movl	%ecx, %r8d	 # _3,
	movq	%rax, %rcx	 # tmp131,
	call	printf	 #
 # main.c:40:     printf("p.c: %p, %8x, %zu\n", &p.c, p.c, sizeof(p.c));
	movzbl	-9(%rbp), %eax	 # p.c, _4
 # main.c:40:     printf("p.c: %p, %8x, %zu\n", &p.c, p.c, sizeof(p.c));
	movzbl	%al, %ecx	 # _4, _5
	leaq	-14(%rbp), %rax	 #, tmp132
	leaq	5(%rax), %rdx	 #, tmp133
	leaq	.LC4(%rip), %rax	 #, tmp134
	movl	$1, %r9d	 #,
	movl	%ecx, %r8d	 # _5,
	movq	%rax, %rcx	 # tmp134,
	call	printf	 #
 # main.c:41:     printf("p.d: %p, %8x, %zu\n", &p.d, p.d, sizeof(p.d));
	movzbl	-8(%rbp), %eax	 # p.d, _6
 # main.c:41:     printf("p.d: %p, %8x, %zu\n", &p.d, p.d, sizeof(p.d));
	movzbl	%al, %ecx	 # _6, _7
	leaq	-14(%rbp), %rax	 #, tmp135
	leaq	6(%rax), %rdx	 #, tmp136
	leaq	.LC5(%rip), %rax	 #, tmp137
	movl	$1, %r9d	 #,
	movl	%ecx, %r8d	 # _7,
	movq	%rax, %rcx	 # tmp137,
	call	printf	 #
 # main.c:42:     printf("p.e: %p, %8x, %zu\n", &p.e, p.e, sizeof(p.e));
	movzbl	-7(%rbp), %eax	 # p.e, _8
 # main.c:42:     printf("p.e: %p, %8x, %zu\n", &p.e, p.e, sizeof(p.e));
	movzbl	%al, %ecx	 # _8, _9
	leaq	-14(%rbp), %rax	 #, tmp138
	leaq	7(%rax), %rdx	 #, tmp139
	leaq	.LC6(%rip), %rax	 #, tmp140
	movl	$1, %r9d	 #,
	movl	%ecx, %r8d	 # _9,
	movq	%rax, %rcx	 # tmp140,
	call	printf	 #
 # main.c:43:     printf("p.f: %p, %8x, %zu\n", &p.f, p.f, sizeof(p.f));
	movzwl	-6(%rbp), %eax	 # p.f, _10
 # main.c:43:     printf("p.f: %p, %8x, %zu\n", &p.f, p.f, sizeof(p.f));
	movzwl	%ax, %ecx	 # _10, _11
	leaq	-14(%rbp), %rax	 #, tmp141
	leaq	8(%rax), %rdx	 #, tmp142
	leaq	.LC7(%rip), %rax	 #, tmp143
	movl	$2, %r9d	 #,
	movl	%ecx, %r8d	 # _11,
	movq	%rax, %rcx	 # tmp143,
	call	printf	 #
 # main.c:45:     uint32_t x = p.b;
	movl	-13(%rbp), %eax	 # p.b, tmp144
	movl	%eax, -4(%rbp)	 # tmp144, x
 # main.c:46:     printf("\n");
	movl	$10, %ecx	 #,
	call	putchar	 #
 # main.c:47:     printf("x  : %x\n", x);
	movl	-4(%rbp), %eax	 # x, tmp145
	leaq	.LC8(%rip), %rcx	 #, tmp146
	movl	%eax, %edx	 # tmp145,
	call	printf	 #
 # main.c:48:     printf("p.b: %x\n", p.b);
	movl	-13(%rbp), %eax	 # p.b, _12
	leaq	.LC9(%rip), %rcx	 #, tmp147
	movl	%eax, %edx	 # _12,
	call	printf	 #
 # main.c:49:     printf("\n");
	movl	$10, %ecx	 #,
	call	putchar	 #
 # main.c:52:     memset(&s, 0, sizeof(s));
	leaq	-32(%rbp), %rax	         # 將 `s` 的位址 (%rbp - 32) 載入到 %rax 中
	movl	$16, %r8d	         # 設定第 3 個參數，size = 16，到 %r8d
	movl	$0, %edx	         # 設定第 2 個參數，value = 0，到 %edx
	movq	%rax, %rcx	         # 設定第 1 個參數，dest = s 的位址，到 %rcx
	call	memset	                 # 呼叫 memset(%rcx, %edx, %r8d)
 # main.c:54:     s.a = 0x11;
	movb	$17, -32(%rbp)	         # 寫入 1 byte 到 (%rbp - 32)
 # main.c:55:     s.b = 0x22334455;
	movl	$573785173, -28(%rbp)	 # 寫入 4 bytes 到 (%rbp - 28)，加入了 3 bytes padding
 # main.c:56:     s.c = 0x66;
	movb	$102, -24(%rbp)	         # 寫入 1 byte 到 (%rbp - 24)
 # main.c:57:     s.d = 0x77;
	movb	$119, -23(%rbp)	         # 寫入 1 byte 到 (%rbp - 23)
 # main.c:58:     s.e = 0x88;
	movb	$-120, -22(%rbp)	 # 寫入 1 byte 到 (%rbp - 22)
 # main.c:59:     s.f = 0x99AA;
	movw	$-26198, -20(%rbp)	 # 寫入 2 bytes 到 (%rbp - 20)
 # main.c:61:     printf("sizeof(s):%zu\n", sizeof(s));
	leaq	.LC10(%rip), %rax	 #, tmp149
	movl	$16, %edx	 #,
	movq	%rax, %rcx	 # tmp149,
	call	printf	 #
 # main.c:62:     printf("&s:%p\n", &s);
	leaq	-32(%rbp), %rax	 #, tmp150
	leaq	.LC11(%rip), %rcx	 #, tmp151
	movq	%rax, %rdx	 # tmp150,
	call	printf	 #
 # main.c:63:     printf("s.a: %p, %8x, %zu\n", &s.a, s.a, sizeof(s.a));
	movzbl	-32(%rbp), %eax	 # s.a, _13
 # main.c:63:     printf("s.a: %p, %8x, %zu\n", &s.a, s.a, sizeof(s.a));
	movzbl	%al, %edx	 # _13, _14
	leaq	-32(%rbp), %rax	 #, tmp152
	leaq	.LC12(%rip), %rcx	 #, tmp153
	movl	$1, %r9d	 #,
	movl	%edx, %r8d	 # _14,
	movq	%rax, %rdx	 # tmp152,
	call	printf	 #
 # main.c:64:     printf("s.b: %p, %8x, %zu\n", &s.b, s.b, sizeof(s.b));
	movl	-28(%rbp), %ecx	 # s.b, _15
	leaq	-32(%rbp), %rax	 #, tmp154
	leaq	4(%rax), %rdx	 #, tmp155
	leaq	.LC13(%rip), %rax	 #, tmp156
	movl	$4, %r9d	 #,
	movl	%ecx, %r8d	 # _15,
	movq	%rax, %rcx	 # tmp156,
	call	printf	 #
 # main.c:65:     printf("s.c: %p, %8x, %zu\n", &s.c, s.c, sizeof(s.c));
	movzbl	-24(%rbp), %eax	 # s.c, _16
 # main.c:65:     printf("s.c: %p, %8x, %zu\n", &s.c, s.c, sizeof(s.c));
	movzbl	%al, %ecx	 # _16, _17
	leaq	-32(%rbp), %rax	 #, tmp157
	leaq	8(%rax), %rdx	 #, tmp158
	leaq	.LC14(%rip), %rax	 #, tmp159
	movl	$1, %r9d	 #,
	movl	%ecx, %r8d	 # _17,
	movq	%rax, %rcx	 # tmp159,
	call	printf	 #
 # main.c:66:     printf("s.d: %p, %8x, %zu\n", &s.d, s.d, sizeof(s.d));
	movzbl	-23(%rbp), %eax	 # s.d, _18
 # main.c:66:     printf("s.d: %p, %8x, %zu\n", &s.d, s.d, sizeof(s.d));
	movzbl	%al, %ecx	 # _18, _19
	leaq	-32(%rbp), %rax	 #, tmp160
	leaq	9(%rax), %rdx	 #, tmp161
	leaq	.LC15(%rip), %rax	 #, tmp162
	movl	$1, %r9d	 #,
	movl	%ecx, %r8d	 # _19,
	movq	%rax, %rcx	 # tmp162,
	call	printf	 #
 # main.c:67:     printf("s.e: %p, %8x, %zu\n", &s.e, s.e, sizeof(s.e));
	movzbl	-22(%rbp), %eax	 # s.e, _20
 # main.c:67:     printf("s.e: %p, %8x, %zu\n", &s.e, s.e, sizeof(s.e));
	movzbl	%al, %ecx	 # _20, _21
	leaq	-32(%rbp), %rax	 #, tmp163
	leaq	10(%rax), %rdx	 #, tmp164
	leaq	.LC16(%rip), %rax	 #, tmp165
	movl	$1, %r9d	 #,
	movl	%ecx, %r8d	 # _21,
	movq	%rax, %rcx	 # tmp165,
	call	printf	 #
 # main.c:68:     printf("s.f: %p, %8x, %zu\n", &s.f, s.f, sizeof(s.f));
	movzwl	-20(%rbp), %eax	 # s.f, _22
 # main.c:68:     printf("s.f: %p, %8x, %zu\n", &s.f, s.f, sizeof(s.f));
	movzwl	%ax, %ecx	 # _22, _23
	leaq	-32(%rbp), %rax	 #, tmp166
	leaq	12(%rax), %rdx	 #, tmp167
	leaq	.LC17(%rip), %rax	 #, tmp168
	movl	$2, %r9d	 #,
	movl	%ecx, %r8d	 # _23,
	movq	%rax, %rcx	 # tmp168,
	call	printf	 #
 # main.c:70:     return 0;
	movl	$0, %eax	         # 將傳回值 0 放入 %eax 暫存器。
 # main.c:71: }
	addq	$64, %rsp	         # 將 stack pointer 加上 64 bytes，釋放區域變數空間。
	popq	%rbp	                 # 還原 caller 的 frame pointer。
	ret	                         # 返回至 caller 的呼叫處。
	.seh_endproc
	.def	__main;	.scl	2;	.type	32;	.endef
	.ident	"GCC: (Rev5, Built by MSYS2 project) 15.1.0"
	.def	memset;	.scl	2;	.type	32;	.endef
	.def	printf;	.scl	2;	.type	32;	.endef
	.def	putchar;	.scl	2;	.type	32;	.endef
</pre>
                </div>
            </div>
        </section>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            const setupTabs = () => {
                const tabGroups = document.querySelectorAll('[data-tab-group]');
                tabGroups.forEach(group => {
                    const groupName = group.dataset.tabGroup;
                    const buttons = group.querySelectorAll('.tab-btn');
                    const contents = document.querySelectorAll(`.tab-content[data-tab-group="${groupName}"]`);

                    buttons.forEach(button => {
                        button.addEventListener('click', () => {
                            const tabId = button.dataset.tab;

                            buttons.forEach(btn => btn.classList.remove('active'));
                            button.classList.add('active');

                            contents.forEach(content => {
                                if (content.id === tabId) {
                                    content.classList.add('active');
                                } else {
                                    content.classList.remove('active');
                                }
                            });
                        });
                    });
                });
            };

            const setupNavScroll = () => {
                const links = document.querySelectorAll('#nav-links a');
                links.forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        const targetId = link.getAttribute('href');
                        const targetElement = document.querySelector(targetId);
                        if (targetElement) {
                            const offset = targetElement.offsetTop - 80;
                            window.scrollTo({ top: offset, behavior: 'smooth' });
                        }
                    });
                });
            };

            const setupNavHighlight = () => {
                const links = document.querySelectorAll('#nav-links a');
                const sections = Array.from(links).map(link => document.querySelector(link.getAttribute('href')));

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const id = entry.target.id;
                            links.forEach(link => {
                                if (link.getAttribute('href') === `#${id}`) {
                                    link.classList.add('active');
                                } else {
                                    link.classList.remove('active');
                                }
                            });
                        }
                    });
                }, { rootMargin: '-80px 0px -50% 0px', threshold: 0.1 });

                sections.forEach(section => {
                    if (section) observer.observe(section);
                });
            };

            const highlightAsm = (targetId) => {
                const targetElement = document.getElementById(targetId);
                if (!targetElement) return;

                const asmSection = document.getElementById('assembly');
                if (!asmSection) return;

                let tabGroup, tabId, btnId;
                if (targetId.startsWith('asm-p-')) {
                    tabGroup = 'asm';
                    tabId = 'asm-p';
                    btnId = 'asm-p';
                } else if (targetId.startsWith('asm-s-')) {
                    tabGroup = 'asm';
                    tabId = 'asm-s';
                    btnId = 'asm-s';
                } else {
                    return;
                }

                document.querySelectorAll(`.tab-btn[data-tab-group="${tabGroup}"]`).forEach(btn => btn.classList.remove('active'));
                document.querySelector(`.tab-btn[data-tab="${btnId}"]`).classList.add('active');

                document.querySelectorAll(`.tab-content[data-tab-group="${tabGroup}"]`).forEach(content => content.classList.remove('active'));
                document.getElementById(tabId).classList.add('active');

                const offset = targetElement.offsetTop - 100;
                targetElement.parentElement.scrollTo({ top: offset, behavior: 'smooth' });

                targetElement.classList.remove('highlight-pulse');
                void targetElement.offsetWidth;
                targetElement.classList.add('highlight-pulse');
            };

            const createCharts = () => {
                const packedCtx = document.getElementById('packedChart').getContext('2d');
                new Chart(packedCtx, {
                    type: 'bar',
                    data: {
                        labels: ['struct pxx'],
                        datasets: [
                            { label: 'a (1b)', data: [1], backgroundColor: '#3b82f6' },
                            { label: 'b (4b)', data: [4], backgroundColor: '#ef4444' },
                            { label: 'c (1b)', data: [1], backgroundColor: '#22c55e' },
                            { label: 'd (1b)', data: [1], backgroundColor: '#eab308' },
                            { label: 'e (1b)', data: [1], backgroundColor: '#8b5cf6' },
                            { label: 'f (2b)', data: [2], backgroundColor: '#ec4899' }
                        ]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { stacked: true, title: { display: true, text: 'Bytes' } },
                            y: { stacked: true, display: false }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: (context) => `${context.dataset.label} | Offset: ${calculateOffset(context.chart.data.datasets, context.datasetIndex)}`
                                }
                            }
                        },
                        onClick: (e, elements) => {
                            if (elements.length > 0) {
                                const datasetIndex = elements[0].datasetIndex;
                                const targetIds = ['asm-p-a', 'asm-p-b', 'asm-p-c', 'asm-p-d', 'asm-p-e', 'asm-p-f'];
                                highlightAsm(targetIds[datasetIndex]);
                            }
                        }
                    }
                });

                const standardCtx = document.getElementById('standardChart').getContext('2d');
                new Chart(standardCtx, {
                    type: 'bar',
                    data: {
                        labels: ['struct sxx'],
                        datasets: [
                            { label: 'a (1b)', data: [1], backgroundColor: '#3b82f6' },
                            { label: 'padding (3b)', data: [3], backgroundColor: '#9ca3af' },
                            { label: 'b (4b)', data: [4], backgroundColor: '#10b981' },
                            { label: 'c (1b)', data: [1], backgroundColor: '#22c55e' },
                            { label: 'd (1b)', data: [1], backgroundColor: '#eab308' },
                            { label: 'e (1b)', data: [1], backgroundColor: '#8b5cf6' },
                            { label: 'padding (1b)', data: [1], backgroundColor: '#9ca3af' },
                            { label: 'f (2b)', data: [2], backgroundColor: '#ec4899' },
                            { label: 'padding (2b)', data: [2], backgroundColor: '#9ca3af' }
                        ]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { stacked: true, title: { display: true, text: 'Bytes' } },
                            y: { stacked: true, display: false }
                        },
                        plugins: {
                            tooltip: {
                                filter: (tooltipItem) => !tooltipItem.dataset.label.startsWith('padding'),
                                callbacks: {
                                    label: (context) => `${context.dataset.label} | Offset: ${calculateOffset(context.chart.data.datasets, context.datasetIndex)}`
                                }
                            }
                        },
                        onClick: (e, elements) => {
                            if (elements.length > 0) {
                                const datasetIndex = elements[0].datasetIndex;
                                const targetIds = { 0: 'asm-s-a', 2: 'asm-s-b', 3: 'asm-s-c', 4: 'asm-s-d', 5: 'asm-s-e', 7: 'asm-s-f' };
                                if (targetIds[datasetIndex]) {
                                    highlightAsm(targetIds[datasetIndex]);
                                }
                            }
                        }
                    }
                });
            };

            const calculateOffset = (datasets, datasetIndex) => {
                let offset = 0;
                for (let i = 0; i < datasetIndex; i++) {
                    offset += datasets[i].data[0];
                }
                return offset;
            };

            setupTabs();
            setupNavScroll();
            setupNavHighlight();
            createCharts();
        });
    </script>
</body>
</html>
